// The SceneGraphToArnoldRenderer object just build the "simple" setup
// where the SceneGraph is directly the input of the render target.
//
// Eventually this will not be enough since we want to support/insert
// a SceneAssembly graph between the source scene(s) and the renderer,
// in which case the SceneAssembly graph itself will provide the SceneGraphWrapper.
object SceneGraphToArnoldRenderer {
  SceneGraph sg;
  SGCamera camera;

  SceneAssemblyToArnoldRenderer sceneAssemblyToArnoldRenderer;
};

SceneGraphToArnoldRenderer( SceneGraph sg ) {
  this.sg = sg;
  SceneGraphWrapper sgWrap(sg);
  sgWrap.setTracingVerboseLevel(3);
  SGInstanceQuery lightGroup = sgWrap.createInstanceQuery( "ArnoldRenderer_lightsQuery", SGBaseLightInstanceFilter() );
  SGInstanceQuery geomInstGroup = sgWrap.createInstanceQuery( "ArnoldRenderer_geomQuery", SGGeometryInstanceFilter() );

  this.sceneAssemblyToArnoldRenderer = SceneAssemblyToArnoldRenderer( sgWrap, geomInstGroup, lightGroup );

  // Register our adaptors
  RegisterAdaptor( SGInstance, ArnoldRendererTargetName, ArnoldRendererToGeometryInstance );
  RegisterAdaptor( SGGeometry, ArnoldRendererTargetName, ArnoldRendererToGeometryInstance );
  RegisterAdaptor( PolygonMesh, ArnoldRendererTargetName, PolygonMeshToArnoldRenderer );
  RegisterAdaptor( SGPointLight, ArnoldRendererTargetName, SGPointLightToArnoldRenderer );
  RegisterAdaptor( SGShadowPointLight, ArnoldRendererTargetName, SGShadowPointLightToArnoldRenderer );

}

SceneGraphToArnoldRenderer.update!( SInt32 frame ) {
  // Prepare the scene graph storage for this frame
  this.sg.defineCurrentFrame( this.sg.getFrameContext( frame ) );
  this.sceneAssemblyToArnoldRenderer.update( this.camera, frame );
}
