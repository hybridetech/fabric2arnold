
// This gets the geometries and lights from the SceneAssembly groups,
// and manages their conversion to ArnoldRenderer adaptors.
//
// These groups (geom + lights) are arbitrary, there could be only one or others.
//
// The SceneAssembly can eventually include more procedural treatment
// such as defining passes, redefining materials, merging or filtering
// scenes, etc. This is why we want to get the elements at this level
// instead of the SceneGraph level.
//
// Another advantage of using groups is that it keeps track of
// the objects of the scene, and will incrementally add/remove/change
// based on the changes in the scene, which could be good for updating
// incrementally the render state when re-rendering, for example
// when adjusting parameters of a light or material, or if
// rendering multiple frames (can only update what is animated).
//
object SceneAssemblyToArnoldRenderer {

  ArnoldRendererTargetGroup geometries;
  ArnoldRendererTargetGroup lights;

  ArnoldRendererContext renderContext;

  CameraToArnoldRenderer camera;
};

SceneAssemblyToArnoldRenderer( SceneWrapper scene, BaseDynamicGroup sourceGeometriesGroup, BaseDynamicGroup sceneLightsGroup ) {
  // Setup initial render context from scene
  this.renderContext = ArnoldRendererContext();
  this.renderContext.renderer = ArnoldRenderer();
  this.renderContext.adaptorTarget = scene.getAdaptorTarget(ArnoldRendererTargetName);
  this.renderContext.sceneContext = scene.createContext();

  this.geometries = ArnoldRendererTargetGroup( sourceGeometriesGroup, this.renderContext, "RenderGeoms" );
  this.lights = ArnoldRendererTargetGroup( sceneLightsGroup, this.renderContext, "RenderLights" );

  this.initArnold();
}

~SceneAssemblyToArnoldRenderer() 
{
  // Before we quit, write out the ass file for reference
  String ass_file = "c:\\temp\\rtr2_out.ass";
  AiASSWrite(ass_file, AI_NODE_ALL, false, true);

  AiEnd();
}

SceneAssemblyToArnoldRenderer.initArnold!()
{
  AiBegin();

  AiMsgSetLogFileName('c:\\temp\\arnold_log.log');
  AiMsgSetLogFileFlags(AI_LOG_DEBUG);

  // set render options
  // Load our default options file
  AiASSLoad('F:/src/staylor_MTL-BD702/dev/tools/GXAssembly/arnold.cfg.ass', AI_NODE_ALL);

  this.camera = CameraToArnoldRenderer();
}

// Updates the render state to the scene, and maybe launches a render.
// The 'context' might include a different frame, in which case only
// the changing values might be updated if doing incremental rendering updates.
//
// The passed-in camera might be something else than a SGCamera,
// for example DCC's camera. Since there's just one active camera it is
// simpler to translate directly instead of using the adaptor mechanism.
SceneAssemblyToArnoldRenderer.update!( SGCamera camera, SInt32 frame ) {
  // To do: update the camera render parameters from 'camera'

  this.renderContext.sceneContext.setFrame( frame );
  this.renderContext.sceneContext.update();
  // 'renderContext' is shared by this.geometries / this.lights
  this.geometries.update();
  this.lights.update();
  this.camera.update(camera, SGContext());

  // Add default light, just for now
  AtNode existingNode = AiNodeLookUpByName('def_ambient');
  if (!existingNode.isValid())
  {
    existingNode = AiNode("ambient_light");
    AiNodeSetFlt(existingNode, 'intensity', 0.2);
  }
}
