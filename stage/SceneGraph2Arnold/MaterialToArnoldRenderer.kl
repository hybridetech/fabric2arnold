require GamExToSceneGraph;

////////////////////////////////////////////////////////////////////////////////////
// Define an adaptor skeleton for SGPointLight.
// This is a simplified hierarchy; a base one could have been defined
// for the SGBaseLight.
object MaterialToArnoldRenderer : BaseSWTransformedAdaptor, ArnoldRendererTargetAdaptor {
  ArnoldRenderer renderer;
  AtNode arnoldMaterial;

  TextureToArnoldRenderer textureAdators[];

  SGObject sourceMaterial;
};

MaterialToArnoldRenderer(SGObject mtl) {
	this.sourceMaterial = mtl;
}

~MaterialToArnoldRenderer() {
}

function AtNode MaterialToArnoldRenderer.getAiNode() {
	return this.arnoldMaterial;
}

function MaterialToArnoldRenderer.setRenderer!(ArnoldRenderer renderer) {
  this.renderer = renderer;

  // This function is our initialization routine, Here we create the material
  String name = this.sourceMaterial.getName();
  AtNode existingNode = AiNodeLookUpByName(name);
  if (existingNode.isValid())
  {
  	//report('NOTE: Creating material with duplicate name!' + name);
  	this.arnoldMaterial = existingNode;
  }
  else
  {
    // We have 2 options when creating a new material.  We will
    // always have the default GamEx material, but we may also
    // have an explicitly constructed arnold shader tree
    // If we have a child material of type _arnoldShader_
    // then we process that, otherwise we just translate the default
	  SGContext context;
	  SGGXMaterial baseMaterial = this.sourceMaterial.getWrapper(context);
    if (baseMaterial == null)
      throw "Cannot handle NULL materials!";

    String arnoldMtlName = baseMaterial.getNameForType('_arnoldMaterialNode_');
    if (arnoldMtlName)
    {
      SGContext arnoldMtlCtxt;
      Ref<SGGXMaterial> arnoldShaderMaterial = baseMaterial.getWrapper(arnoldMtlName, context, arnoldMtlCtxt);
      if (arnoldShaderMaterial != null)
      {
      report('Found Arnold material');
        this.arnoldMaterial = this.translateArnoldMaterial(arnoldShaderMaterial, arnoldMtlCtxt);
      }
    }

    if (!this.arnoldMaterial.isValid())
    {
      // If we haven't successfully translated yet, we translate the default
      this.translateGamExMaterial(baseMaterial, context); 
    }
  }
}


// Create an Arnold material based on default GameX shader parameters
function Boolean MaterialToArnoldRenderer.translateGamExMaterial!(SGGXMaterial baseMaterial, SGContext ctxt)
{
  String name = this.sourceMaterial.getName();
  this.arnoldMaterial = AiNode("standard");
  AiNodeSetStr(this.arnoldMaterial, "name", name);

  // The only parameters we can set are the textures in the file.
  // We could translate more, but I'd need to spend a bit longer figuring
  // out how the parameters translate.
  for (UInt32 i = 0; i < baseMaterial.size(); i++)
  {
    String childName = baseMaterial.getName(i);
    SGContext texctxt;
    Ref<SGObjectWrapper> wrappedObject = baseMaterial.getWrapper(childName, ctxt, texctxt);

    Ref<SGGXTexture> wrappedTexture = wrappedObject;
    if (wrappedTexture == null)
      continue;

    // Its easiest to work directly with SG than its wrappers.
    // This makes me think I've implemented the wrappers... badly...
    SGObject sgTexture = wrappedTexture.getWrapped(texctxt);
    SGObjectProperty typeProperty = sgTexture.getLocalProperty('MapType');
    if (!typeProperty.isValid())
      continue;

    
    TextureToArnoldRenderer adaptor = TextureToArnoldRenderer(sgTexture);
    adaptor.setRenderer(this.renderer);
    AtNode texNode = adaptor.getAiNode();

  	String type = typeProperty.getStringValue();
    if (type == 'Normal') 
  	{
      // After a bit of experimentation, it looks like the
      // normal maps are completely screwing our render.
      // Perhaps the normal maps don't mean the same thing in GamEx & arnold?
      continue;
  		// Normal maps are treated slightly differently, (or at least
  		// the ones exported from XSi are).  We need to create a different shader
      // type = '@before';
      // String normalName = childName + '.Normal';

      // // Create an interim map to handle the normalizing-ness
      // AtNode normalShader = AiNode('XSINormalMap3');
      // AiNodeSetStr(normalShader, 'name', normalName);
      // AiNodeLink(texNode, 'Map', normalShader);
      // AiNodeLink(normalShader, type, this.arnoldMaterial);
  	}
  	else
  	{
  	  if (type == 'Diffuse') type = 'Kd_color';
  		else if (type == 'Specular') type = 'Ks_color';
  		else {
  			report("ERROR: Uknown map type: " + type);
  			continue;
  		}

  		AiNodeLink(texNode, type, this.arnoldMaterial);
  		this.textureAdators.push(adaptor);
	  }
  }

  return true;
}

// Create an Arnold material based on default GameX shader parameters
function AtNode MaterialToArnoldRenderer.translateArnoldMaterial!(SGGXMaterial arnoldMaterial, SGContext ctxt)
{
  SGObject sgShader = arnoldMaterial.getWrapped(ctxt);
  SGObjectProperty typeProperty = sgShader.getLocalProperty('arnold_type'); 
  if (!typeProperty.isValid())
    return AtNode(); // We cannot translate without knowing the shader type

  AtNode arnoldShader = AiNode(typeProperty.getStringValue());
  if (!arnoldShader.isValid())
    return AtNode();

  // Set name parameter explicitly
  String name = sgShader.getName();
  AiNodeSetStr(arnoldShader, "name", name);

  // Translate all parameters
  SGObjectPropertyIterator propIter = sgShader.getPropertyIterator();
  SGObjectProperty property;
  while (propIter.getNext(property))
  {
    // All property types get set as subdata's on the accessor
    String propName = property.getName();

    // Ignore the type property and default GX properties (uppercase)
    if (propName == 'arnold_type' || propName.upper() == propName)
      continue;

    Type propType = property.getType();
    switch(propType)
    {
      case Boolean:
        Boolean v = property.getBooleanValue();
        AiNodeSetBool(arnoldShader, propName, v);
        break;      
      case UInt32:
        UInt32 v = property.getUInt32Value();
        AiNodeSetInt(arnoldShader, propName, v);
        break;
      case SInt32:
        UInt32 v = property.getSInt32Value();
        AiNodeSetInt(arnoldShader, propName, v);
        break;
      case Float32:
        Float32 v = property.getFloat32Value();
        AiNodeSetFlt(arnoldShader, propName, v);
        break;
      case Vec3:
        Vec3 v = property.getVec3Value();
        AiNodeSetVec(arnoldShader, propName, v.x, v.y, v.z);
        break;
/*      case Vec4:
        Vec4 v = property.getVec4Value();
        AiNodeSetVec(arnoldShader, propName, v.x, v.y, v.z);
        break;
*/
      case Mat44:
        Mat44 v;
        property.getValue(v);
        AiNodeSetMatrix(arnoldShader, propName, v);
        break;
      case String:
        String v = property.getStringValue();
        AiNodeSetStr(arnoldShader, propName, v);
        break;
      case Box3:
        // We are throwing lots of errors from translating these Box3 values (poorly)
        // There are no shader Box3 values AFAIK, so lets not spam by saying we 
        // are failing to translate them.
        break;
      //case GamExID:
      //   GamExID v = property.getGamExIDValue();
      //   subData.setSubData(propName, v);
      //   break;
      case SGInstanceReference:
        // Arnold shaders can reference sub-shaders for their values.  Hook those up now...
        SGObject subObj = property.getReferenceTarget();
        if (!subObj.isValid())
          break;
        SGContext subctxt;
        SGGXMaterial childShader = subObj.getWrapper(subctxt);
        if (childShader != null) 
        {
          String valueType = arnoldMaterial.getTypeForName(propName);
          AtNode childArnoldShader = this.translateArnoldMaterial(childShader, subctxt);
          if (childArnoldShader.isValid()) 
          {
            AiNodeLink(childArnoldShader, valueType, arnoldShader);
          }
        }
        break;

      default:
        setError("Saving Unsupported type: " + propType);
        break;
    }
  }
  return arnoldShader;
}

Boolean MaterialToArnoldRenderer.update!(Ref<SWContext> swContext) {

  this.parent.update( swContext );

  for (UInt32 i = 0; i < this.textureAdators.size(); i++)
  {
  	this.textureAdators[i].update(swContext);
  }

  return true;
}