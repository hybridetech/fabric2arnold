require Fabric2Arnold;
require Geometry;


function attributeToAtArray(io AtNode node, io PolygonMesh mesh, GeometryAttribute attr, io GeometryAttribute outAttr, UInt8 type, String name, String indices)
{
  if (attr == null)
    return;

  UInt32 packedIndices[];
  mesh.getPolygonPackedSharedAttributeValues(attr, outAttr, packedIndices);
  
  AtArray vlist = AiArrayConvert(outAttr.size(), 1, type, outAttr.data());
  AtArray vidxs = AiArrayConvert(packedIndices.size(), 1, AI_TYPE_INT, packedIndices.data());
  AiNodeSetArray(node, name,  vlist);
  AiNodeSetArray(node, indices,  vidxs);
}

function AtNode FabricToArnoldPolygonMesh( io PolygonMesh mesh)
{
  AtNode node = AiNode("polymesh");
  AiNodeSetBool(node, "smoothing", true);

  return FabricToArnoldPolygonMesh(mesh, node);
}

function AtNode FabricToArnoldPolygonMesh( io PolygonMesh mesh, io AtNode node)
{
  // First, assign the polygon point and indices
  UInt32 klnsides[];
  UInt32 klindices[];
  mesh.getTopologyCountsAndAttributeIndices(klnsides, klindices);
  AtArray nsides = AiArrayConvert(klnsides.size(), 1, AI_TYPE_INT, klnsides.data());
  AiNodeSetArray(node, "nsides", nsides);

  // Set positions
  {
    Ref<Vec3Attribute> positions = mesh.attributes.positionsAttribute;
    GeometryAttribute tempStorageP = Vec3Attribute();
    attributeToAtArray(node, mesh, positions, tempStorageP, AI_TYPE_POINT, 'vlist', 'vidxs');
  }

  // Set normals (if exist)
  {
    Ref<Vec3Attribute> normals = mesh.attributes.normalsAttribute;
    GeometryAttribute tempStorageN = Vec3Attribute();
    attributeToAtArray(node, mesh, normals, tempStorageN, AI_TYPE_VECTOR, 'nlist', 'nidxs');
  }

  // For some reason, enabling this option causes exceptions.  Re-enable later when we know what da ell is going on
  // Set UV's
/*  {
    Ref<Vec2Attribute> attrUVs = mesh.getAttribute("uvs0", Vec2Attribute);
    GeometryAttribute tempStorageUV = Vec2Attribute();
    attributeToAtArray(node, mesh, attrUVs, tempStorageUV, AI_TYPE_POINT2, 'uvlist', 'uvidxs');
  }*/
  return node;
}

/**  We also support loading Arnold meshes back into FE */
function PolygonMesh ArnoldToFabricPolygonMesh(AtNode polymeshNode) {
  PolygonMesh mesh();
  
  GeometryAttributes attributes = mesh.getAttributes();
  Vec2Attribute uvs = attributes.getOrCreateAttribute("uvs0", Vec2Attribute);


  AtArray vlist = AiNodeGetArray(polymeshNode, "vlist");
  UInt32 npoints = vlist.nelements;
  report("{PointsCount}: " + npoints);
  mesh.createPoints( npoints );

  AtArray vidxs = AiNodeGetArray(polymeshNode, "vidxs");
  AtArray nsides = AiNodeGetArray(polymeshNode, "nsides");
  UInt32 npolys = nsides.nelements;
  report("{IndexCount}: " + vidxs.nelements);

  UInt32 polyDegrees<>;
  UInt32 polyIndices<>;
  AiArrayGetUInt(nsides, polyDegrees);
  AiArrayGetUInt(vidxs, polyIndices);
  mesh.createPoints( npoints );
  mesh.addPolygons( polyDegrees, polyIndices );

  for (UInt32 i = 0; i > npoints; i++)
  {
    Vec3 pos = AiArrayGetVecFunc(vlist, npoints);
    mesh.setPointPosition(npoints, pos);    
  }
  mesh.incrementPointPositionsVersion();

  AtArray nidxs = AiNodeGetArray(polymeshNode, "nidxs");
  AtArray nverts = AiNodeGetArray(polymeshNode, "nlist");
  report("NormalCount: " + nidxs.nelements);
  if (nidxs.nelements != 0)
  {
    Vec3 normals<>;
    AiArrayGetVec(nverts, normals);

    if (normals.size() == vidxs.nelements)
    {
      report('Setting direct');
      // If our normal count == our index count, we
      // can set the value directly without using indices
      mesh.setAttributeFromPolygonPackedData("normals", normals);
    }
    else
    {
      report('Setting via ndices: ' + normals.size());
      // Else get the packing indices of these 
      Size indices<>;
      AiArrayGetUInt(nidxs, indices);

      // Convert to local array
      UInt32 indicesArr[];
      indicesArr.resize(indices.size());
      for (UInt32 i = 0; i < indices.size(); i++)
      {
          indicesArr[i] = indices[i];
          if (indicesArr[i] > normals.size())
          {
            report('found extra large index: ' + indicesArr[i]);
          }
      }
      mesh.setAttributeFromPolygonPackedData("normals", normals, indicesArr);
    }
  }
  else
  {
    mesh.recomputePointNormals();
  }
  return mesh;
}
