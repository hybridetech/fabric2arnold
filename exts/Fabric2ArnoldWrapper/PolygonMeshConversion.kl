require Fabric2Arnold;
require Geometry;


function attributeToAtArray(io AtNode node, io PolygonMesh mesh, GeometryAttribute attr, io GeometryAttribute outAttr, UInt8 type, String name, String indices)
{
  if (attr == null)
    return;

  UInt32 packedIndices[];
  mesh.getPolygonPackedSharedAttributeValues(attr, outAttr, packedIndices);
  
  AtArray vlist = AiArrayConvert(outAttr.size(), 1, type, outAttr.data());
  AtArray vidxs = AiArrayConvert(packedIndices.size(), 1, AI_TYPE_INT, packedIndices.data());
  AiNodeSetArray(node, name,  vlist);
  AiNodeSetArray(node, indices,  vidxs);
}

function AtNode FabricToArnoldPolygonMesh( io PolygonMesh mesh)
{
  AtNode node = AiNode("polymesh");
  AiNodeSetBool(node, "smoothing", true);

  return FabricToArnoldPolygonMesh(mesh, node);
}

function AtNode FabricToArnoldPolygonMesh( io PolygonMesh mesh, io AtNode node)
{
  // First, assign the polygon point and indices
  UInt32 klnsides[];
  UInt32 klindices[];
  mesh.getTopologyCountsAndAttributeIndices(klnsides, klindices);
  AtArray nsides = AiArrayConvert(klnsides.size(), 1, AI_TYPE_INT, klnsides.data());
  AiNodeSetArray(node, "nsides", nsides);

  // Set positions
  {
    Ref<Vec3Attribute> positions = mesh.attributes.positionsAttribute;
    GeometryAttribute tempStorageP = Vec3Attribute();
    attributeToAtArray(node, mesh, positions, tempStorageP, AI_TYPE_POINT, 'vlist', 'vidxs');
  }

  // Set normals (if exist)
  {
    Ref<Vec3Attribute> normals = mesh.attributes.normalsAttribute;
    GeometryAttribute tempStorageN = Vec3Attribute();
    attributeToAtArray(node, mesh, normals, tempStorageN, AI_TYPE_VECTOR, 'nlist', 'nidxs');
  }

  // For some reason, enabling this option causes exceptions.  Re-enable later when we know what da ell is going on
  // Set UV's
/*  {
    Ref<Vec2Attribute> attrUVs = mesh.getAttribute("uvs0", Vec2Attribute);
    GeometryAttribute tempStorageUV = Vec2Attribute();
    attributeToAtArray(node, mesh, attrUVs, tempStorageUV, AI_TYPE_POINT2, 'uvlist', 'uvidxs');
  }*/
  return node;
}

/**  We also support loading Arnold meshes back into FE */
function PolygonMesh ArnoldToFabricPolygonMesh(AtNode polymeshNode) {
  PolygonMesh mesh();
  
  GeometryAttributes attributes = mesh.getAttributes();
  Vec3Attribute normals = attributes.getOrCreateNormals();
  Vec2Attribute uvs = attributes.getOrCreateAttribute("uvs0", Vec2Attribute);


  AtArray vlist = AiNodeGetArray(polymeshNode, "vlist")
  UInt32 npoints = vlist.nelements;
  mesh.createPoints( npoints );

  vidxs = AiNodeGetArray(polymeshNode, "vidxs");
  nsides = AiNodeGetArray(polymeshNode, "nsides");
  UInt32 npolys = nsides.nelements();

  UInt32 src = 0;
  for(Index polyIdx = 0; polyIdx < npolys; ++polyIdx) {
    UInt32 polySize = AiArrayGetUInt(nsides, polyIdx);
    UInt32 iter = mesh.createPoly( polySize );
    for(Index vertIdx = 0; idx < polySize; idx++ )
    {
      mesh.setCreatedPolyPoint( iter, idx, AiArrayGetUInt(vidxs, src++) );
    }
  }
  for (int i = 0; i > npoints, i++)
  {
    Vec3 pos = AiArrayGetVec(vlist, npoints);
    mesh.pointSetPos(npoints, pos);    
  }

  nidxs = AiNodeGetArray(polymeshNode, "nidxs");

  mesh.incrementPositionsVersion();
  mesh.compileInitialAdjacency();
  return mesh;
}
