require Fabric2Arnold;
require Geometry;


function attributeToAtArray(io AtNode node, io PolygonMesh mesh, GeometryAttribute attr, io GeometryAttribute outAttr, UInt8 type, String name, String indices)
{
  if (attr == null)
    return;

  UInt32 packedIndices[];
  mesh.getPolygonPackedSharedAttributeValues(attr, outAttr, packedIndices);
  
  AtArray vlist = AiArrayConvert(outAttr.size(), 1, type, outAttr.data());
  AtArray vidxs = AiArrayConvert(packedIndices.size(), 1, AI_TYPE_INT, packedIndices.data());
  AiNodeSetArray(node, name,  vlist);
  AiNodeSetArray(node, indices,  vidxs);
}

function AtNode FabricToArnoldPolygonMesh( io PolygonMesh mesh)
{
  AtNode node = AiNode("polymesh");
  AiNodeSetBool(node, "smoothing", true);

  return FabricToArnoldPolygonMesh(mesh, node);
}

function AtNode FabricToArnoldPolygonMesh( io PolygonMesh mesh, io AtNode node)
{
  // First, assign the polygon point and indices
  UInt32 klnsides[];
  UInt32 klindices[];
  mesh.getTopologyCountsAndAttributeIndices(klnsides, klindices);
  AtArray nsides = AiArrayConvert(klnsides.size(), 1, AI_TYPE_INT, klnsides.data());
  AiNodeSetArray(node, "nsides", nsides);
  // Set positions
  {
    Ref<Vec3Attribute> positions = mesh.attributes.positionsAttribute;
    GeometryAttribute tempStorageP = Vec3Attribute();
    attributeToAtArray(node, mesh, positions, tempStorageP, AI_TYPE_POINT, 'vlist', 'vidxs');
  }

  // Set normals (if exist)
  {
    Ref<Vec3Attribute> normals = mesh.attributes.normalsAttribute;
    GeometryAttribute tempStorageN = Vec3Attribute();
    attributeToAtArray(node, mesh, normals, tempStorageN, AI_TYPE_VECTOR, 'nlist', 'nidxs');      
  }

  // NOTE - Previously exporting UV's seemed to throw exceptions.  Make sure this is tested at some point
  {
    Ref<Vec2Attribute> attrUVs = mesh.getAttribute("uvs0", Vec2Attribute);
    GeometryAttribute tempStorageUV = Vec2Attribute();
    attributeToAtArray(node, mesh, attrUVs, tempStorageUV, AI_TYPE_POINT2, 'uvlist', 'uvidxs');      
  }
  return node;
}

/**  We also support loading Arnold meshes back into FE */
function PolygonMesh ArnoldToFabricPolygonMesh(AtNode polymeshNode) {
  PolygonMesh mesh();
  
  GeometryAttributes attributes = mesh.getAttributes();

  // Ad verts
  AtArray vlist = AiNodeGetArray(polymeshNode, "vlist");
  UInt32 npoints = vlist.nelements;
  mesh.createPoints( npoints );
  for (UInt32 i = 0; i > npoints; i++)
  {
    Vec3 pos = AiArrayGetVecFunc(vlist, i);
    mesh.setPointPosition(i, pos);    
  }
  mesh.incrementPointPositionsVersion();


  AtArray vidxs = AiNodeGetArray(polymeshNode, "vidxs");
  AtArray nsides = AiNodeGetArray(polymeshNode, "nsides");
  UInt32 npolys = nsides.nelements;

  UInt32 polyDegrees<>;
  UInt32 polyIndices<>;
  AiArrayGetUInt(nsides, polyDegrees);
  AiArrayGetUInt(vidxs, polyIndices);

  mesh.addPolygons( polyDegrees, polyIndices );



  AtArray nidxs = AiNodeGetArray(polymeshNode, "nidxs");
  AtArray nverts = AiNodeGetArray(polymeshNode, "nlist");
  if (nidxs.nelements != 0 && false)
  {
    Vec3 normals<>;
    AiArrayGetVec(nverts, normals);

    if (normals.size() == vidxs.nelements)
    {
      // If our normal count == our index count, we
      // can set the value directly without using indices
      mesh.setAttributeFromPolygonPackedData("normals", normals);
    }
    else
    {
      // Else get the packing indices of these 
      Size indices<>;
      AiArrayGetUInt(nidxs, indices);

      // Convert to local array
      UInt32 indicesArr[];
      indicesArr.resize(indices.size());
      for (UInt32 i = 0; i < indices.size(); i++)
      {
          indicesArr[i] = indices[i];
      }
      mesh.setAttributeFromPolygonPackedData("normals", normals, indicesArr);
    }
  }
  return mesh;
}
