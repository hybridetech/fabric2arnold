<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.10">
  <compounddef id="class_at_string" kind="class" language="C++" prot="public">
    <compoundname>AtString</compoundname>
    <includes refid="ai__string_8h" local="no">ai_string.h</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_at_string_1a45da69ccd911fa17662e0e8ff20f2db3" prot="private" static="no" mutable="no">
        <type>const char *</type>
        <definition>const char* AtString::data</definition>
        <argsstring></argsstring>
        <name>data</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="101" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="101" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_at_string_1afc9d0b5e5d7371dbd3e4bc47999d37e5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>AtString::AtString</definition>
        <argsstring>()</argsstring>
        <name>AtString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="42" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="42" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a428bc7406da3c54257b9164076fe81b3" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>AtString::AtString</definition>
        <argsstring>(const char *str)</argsstring>
        <name>AtString</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creating an <ref refid="class_at_string" kindref="compound">AtString</ref> from a char* is an expensive operation. Try not to do this often. Passing NULL to the <ref refid="class_at_string" kindref="compound">AtString</ref> constructor is valid and <ref refid="class_at_string_1ac49a4e29de8d568878f757835dbf8587" kindref="member">c_str()</ref> will then return NULL. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="49" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="49" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a18bbcb6ee9dbeb6eeba92b5473b13bd3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>AtString::AtString</definition>
        <argsstring>(const AtString &amp;str)</argsstring>
        <name>AtString</name>
        <param>
          <type>const <ref refid="class_at_string" kindref="compound">AtString</ref> &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copying and assigning an <ref refid="class_at_string" kindref="compound">AtString</ref> from an <ref refid="class_at_string" kindref="compound">AtString</ref> is very fast. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="54" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="54" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a905d80f9157677ccf10720e0107ae194" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="class_at_string" kindref="compound">AtString</ref> &amp;</type>
        <definition>const AtString&amp; AtString::operator=</definition>
        <argsstring>(const AtString &amp;str)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="class_at_string" kindref="compound">AtString</ref> &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="55" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="55" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a61f49cc1e83483d18acd294dcc715caf" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool AtString::operator==</definition>
        <argsstring>(const AtString &amp;rhs) const </argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="class_at_string" kindref="compound">AtString</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Comparing two <ref refid="class_at_string" kindref="compound">AtString</ref> is an extremely fast pointer comparison. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="63" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="63" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a38c4fe14cb9d05ead6009bfaddd120fc" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool AtString::operator!=</definition>
        <argsstring>(const AtString &amp;rhs) const </argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="class_at_string" kindref="compound">AtString</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="64" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="64" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1abf75ef370f0c5dee9f5edda8aa7b745a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AtString::length</definition>
        <argsstring>() const </argsstring>
        <name>length</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Computing the length is a fast constant time operation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="69" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="69" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a56d4931fa28842b1ebd5b553f3091a4d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool AtString::empty</definition>
        <argsstring>() const </argsstring>
        <name>empty</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>returns true if underlying char* is NULL or &quot;&quot;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="74" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="74" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a21d1d3e1b5ef708ea9914f48772c1546" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>AtString::operator const char *</definition>
        <argsstring>() const </argsstring>
        <name>operator const char *</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="class_at_string" kindref="compound">AtString</ref> will automatically call <ref refid="class_at_string_1ac49a4e29de8d568878f757835dbf8587" kindref="member">c_str()</ref> in most situations and so can be automatically used in places that expect a <computeroutput>char*</computeroutput>. However, functions with a variable number of arguments (printf, AiMsg, ...) will require manually converting to char* with the <ref refid="class_at_string_1ac49a4e29de8d568878f757835dbf8587" kindref="member">c_str()</ref> member function.</para><para><programlisting><codeline><highlight class="normal">void<sp/>Bar(const<sp/>char*<sp/>str);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>Foo(const<sp/>AtString<sp/>astr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Bar(astr);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>passing<sp/>AtString<sp/>to<sp/>a<sp/>function<sp/>that<sp/>expects<sp/>a<sp/>const<sp/>char*<sp/>happens<sp/>automatically</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>const<sp/>char*<sp/>cstr<sp/>=<sp/>astr;<sp/><sp/>//<sp/>likewise,<sp/>passing<sp/>an<sp/>AtString<sp/>to<sp/>a<sp/>const<sp/>char*<sp/>is<sp/>automatic.<sp/><sp/>These<sp/>have<sp/>no<sp/>overhead.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>printf(&quot;calling<sp/>printf<sp/>must<sp/>use<sp/>c_str()<sp/>method:<sp/>%s&quot;,<sp/>astr.c_str());</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="90" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="90" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1ac49a4e29de8d568878f757835dbf8587" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* AtString::c_str</definition>
        <argsstring>() const </argsstring>
        <name>c_str</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the string as a <computeroutput>const char*</computeroutput>. Calling this directly is not normally needed and instead an <ref refid="class_at_string" kindref="compound">AtString</ref> can be directly used as if it was a <computeroutput>const char*</computeroutput> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="96" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="96" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="class_at_string_1a78f37def7fe613c8cd5dcaf0ed79bab6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void AtString::clear</definition>
        <argsstring>()</argsstring>
        <name>clear</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="98" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="98" bodyend="98"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Arnold String allows for fast string comparisons. Since it is expensive to create, try to create an <ref refid="class_at_string" kindref="compound">AtString</ref> once in a preprocess, for instance in <computeroutput>node_initialize</computeroutput>, and then reuse it instead of creating it over and over, for instance, in shader_evaluate where it could get called millions of times. For string constants, use a <computeroutput>static const</computeroutput> in the function, or better yet, in the global scope:</para><para><programlisting><codeline><highlight class="normal">static<sp/>const<sp/>AtString<sp/>some_string(&quot;some_string&quot;);<sp/>//<sp/>this<sp/>is<sp/>created<sp/>only<sp/>once</highlight></codeline>
<codeline><highlight class="normal">void<sp/>Foo()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>func_that_uses_string(some_string);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The underlying string data contained by an <ref refid="class_at_string" kindref="compound">AtString</ref> will exist over the entire lifetime of the arnold library. If you unload the arnold library in your process, any <ref refid="class_at_string" kindref="compound">AtString</ref> objects still in existence will become invalid and using them will likely result in a crash or other undefined behavior. </para>    </detaileddescription>
    <location file="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" line="40" column="1" bodyfile="E:/dev/Arnold SDK/Arnold-4.2.7.5/include/ai_string.h" bodystart="40" bodyend="116"/>
    <listofallmembers>
      <member refid="class_at_string_1afc9d0b5e5d7371dbd3e4bc47999d37e5" prot="public" virt="non-virtual"><scope>AtString</scope><name>AtString</name></member>
      <member refid="class_at_string_1a428bc7406da3c54257b9164076fe81b3" prot="public" virt="non-virtual"><scope>AtString</scope><name>AtString</name></member>
      <member refid="class_at_string_1a18bbcb6ee9dbeb6eeba92b5473b13bd3" prot="public" virt="non-virtual"><scope>AtString</scope><name>AtString</name></member>
      <member refid="class_at_string_1ac49a4e29de8d568878f757835dbf8587" prot="public" virt="non-virtual"><scope>AtString</scope><name>c_str</name></member>
      <member refid="class_at_string_1a78f37def7fe613c8cd5dcaf0ed79bab6" prot="public" virt="non-virtual"><scope>AtString</scope><name>clear</name></member>
      <member refid="class_at_string_1a45da69ccd911fa17662e0e8ff20f2db3" prot="private" virt="non-virtual"><scope>AtString</scope><name>data</name></member>
      <member refid="class_at_string_1a56d4931fa28842b1ebd5b553f3091a4d" prot="public" virt="non-virtual"><scope>AtString</scope><name>empty</name></member>
      <member refid="class_at_string_1abf75ef370f0c5dee9f5edda8aa7b745a" prot="public" virt="non-virtual"><scope>AtString</scope><name>length</name></member>
      <member refid="class_at_string_1a21d1d3e1b5ef708ea9914f48772c1546" prot="public" virt="non-virtual"><scope>AtString</scope><name>operator const char *</name></member>
      <member refid="class_at_string_1a38c4fe14cb9d05ead6009bfaddd120fc" prot="public" virt="non-virtual"><scope>AtString</scope><name>operator!=</name></member>
      <member refid="class_at_string_1a905d80f9157677ccf10720e0107ae194" prot="public" virt="non-virtual"><scope>AtString</scope><name>operator=</name></member>
      <member refid="class_at_string_1a61f49cc1e83483d18acd294dcc715caf" prot="public" virt="non-virtual"><scope>AtString</scope><name>operator==</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
